---
title: "3.time and Order"
date: 2022-07-23T14:33:45+09:00
draft: true
---

> 다음에서 발췌
> [](http://book.mixu.net/distsys/time.html)

# 3. Time and Order

순서란 무엇이고, 왜 중요할까요?

"순서란 무엇인가" 라는 질문은 무슨 의미 일까요 ?

애초에 왜 여기에 왜 빠져있는 걸까요? 왜 우리는 A 가 B 이전에 실행되었다는걸 신경 써야할까요? 왜 우리는 다른 주제에는 신경을 안쓸까요 ? 색깔 같은거?

글쎄, 친구, 일단 이에 답변하기 위해 분산 시스템을 다시 살펴보도록 합시다.

기억하고 있을지 모르겠는데, 분산프로그래밍을 복수의 컴퓨터를 활용해서 같은 문제를 해결하는 예술이라고 묘사했었습니다.

이것은, 사실, 순서에 대한 강박(obsession)의 가장주요한 내용입니다. 어떤 시스템이든 한 번에 하나의 작업만 할수있고, 연산들의 모든 순서를 생성하게 됩니다. 사람들이 하나의 문을 통해 지나다니는것처럼, 모든 연산은 잘 정의된 전처리와 후처리로 구성됩니다. 이것이 우리가 보존하기위해 노력하고 있는 기본적인 프로그래밍 모델입니다.


전통적인 모델은: 하나의 싱글 프로그램, 하나의 프로세스, 하나의 메모리 공간이 하나의 CPU 에서 도는 것입니다. 운영체제는 다중 CPU 와 다중 프로그램에 대한 사실들을 추상화하고, 많은 프로그램들이 실 제로 메모리를 공유하는 것을 추상화 합니다. 저는 스데디드 프로그래밍과 이벤트 기바 프로그래밍이 존재하지 않다고 얘기하지는 않았습니다; 이것은 단지 이것들이 "하나/하나/하나"모델들 위에서 특별하게 추상화 되어있다는 것을 이야기하고 있습니다. 프로그램들은 순서대로 실행되도록 쓰여지게 됩니다; 최 상위에서 시작하여, 아래로 점점 내려가게 됩니다.

속성으로서의 순서는 많은 주목을 받았는데, "정확함"을 정의하는 가장 쉬운방법이 "하나의 기계에서 작동하듯 동작한다" 이기 때문입니다. 그리고 이것은 모동 다음을 의미하는데 a) 우리는 같은 연산을 수행하고 b) 복수의 기계에서도 같은 순서로 실행한다.

순서를 보존하는 분산시스템의 장점은, (하나의 장비에서 정의된것 처럼) 이들이 일반적이다, 라는 것입니다. 당신은 어떤 연산들인지 고려할 필요가 없는데, 왜냐하면 하나의 머신에서 동작하는 것과 완전히 똑같이 실행될 것이기 때문입니다.
이것은 당신이 어떤 연산들이든 간에 같은 시스템을 사용할 수 있다는 것을 알고있기때문에 훌륭합니다. 


## Total and partial order 

분산시스템의 자연적인 상태는 parital order 입니다. 네트워크나 독립적인 노드들 모두 상대적인 순서만을 보장합니다; 그러나 각각의 노드에서는 지역적인 순서를. 관찰할 수 있습니다.

완전한 순서는 이진 관계(binary relation)인데, 집합의 모든 요소의 순서를 정의합니다. 

두개의 구분된 요소는 그 중의 하나가 다른 것보다 더 클 경우에 비교가 가능합니다. 
부분적으로 정렬된 집합은, 요소들의 어떤 쌍이 비교가능하지 않은데, 부분적인 순서는 모든 항목들에 대해 정확한 순서를 지정하지 않기 때문입니다. 

저체 순서와 일부 순서는 전이관계(transitive) 이고 비대칭입니다. 아래의 문구는 전체 순서와 부분순서를 모든 X 의 모든 a,b,c 에 대해 유효합니다.

```
If a <= b and b <= a then a = b (antisymmetry); 
If a <= b and b <= c then a <= c (transitivy);
```

그러나, 전체 순서는 "[전체](http://en.wikipedia.org/wiki/Total_relation)"입니다: 

```
a <= b or b <= a (totality) for all a, b in X
```

부분순서는 오직 반사적인 반면에요:

```
a <= a (refelxitvity) for all a in X
```

전체성은 반사성을 내포하고 있음을 참고해주세요; 따라서, 부분순서는 전체 순서의 더 약한 변종입니다. 모든 부분순서의 어떤 요소들은, 전체정은 보존되지 않을 수 있습니다 - 다시말해, 어떤 요소들은 비교가 불가합니다.

git 브랜치가 부분순서의 하나의 예입니다. 당신은 알고 있을지도 모르겠는데, 깃 리비젼은 하나의 기본 브랜치에서 여러 복수 브랜치를 생성할 수 있도록 해줍니다 - 예를 들어, 마스터 브랜치에서요. 각각의 브랜치는 공통의 조상으로부터 기반해서 바생된 소스코드의 변화들의 역사를 나타내게 됩니다.


```
[ branch A (1,2,0)]  [ master (3,0,0) ]  [ branch B (1,0,2) ]
[ branch A (1,1,0)]  [ master (2,0,0) ]  [ branch B (1,0,1) ]
                  \  [ master (1,0,0) ]  /
```


A 와 B 브랜치는 하나의 공통브랜치로부터 파생됐는데, 둘 사이에 어떤 결정적인 순서는 없습니다; 그들은 각각의 다른 역사를 가지고 있고, 추가적인 작업없이 (merging)  하나의 선형으로 좁혀 질 수 없습니다. 물론, 당신은 모든 커밋을 어떤 임의의 순서로 (첫번째로 조상을 두고, 연결들을 부숴서 A 를 B 이전에 두거나, B 를 A 이전에 두거나 하는 방식으로요) - 그러나 이것은 존재하지 않는 전체 순서를 강제로 둠으로써 정보를 잃어버릴 수 있습니다.

하나의 노드의 시스템에서, 전체 순서는 필수적으로 등장하게 됩니다: 명령들은 실행되고 메시지들은 처리되는데, 하나의 프로그램에서 관측가능하게 됩니다. 우리는 이것을 전체 순서라고 믿을 수 있게 됩니다 - 이것은 프로그램의 동작을 예측가능하게 만들어 줍니다. 이런 순서는 분산시스템에서도 유지 될 수 있지만, 비용을 요구하게 됩니다; 통신은 비싸고, 시간 동기화는 어렵고 깨지기 쉽습니다.


## What is time ?

시간은 순서의 원천입니다. - 연산의 순서를 정의할 수 있게 해줍니다. - 동일하게 해석을 갖고 사람들이 이해할 수 있습니다. (초, 분, 하루 등.)

어떤 감각에서, 시간은 다른 정수 카운터와 유사합니다. 이것은 대부분의 컴퓨터에서 타임 센서(clock)를 할당하고 있기 때문에 중요합니다. 이것은 또 중요한데, 우리는 물리 실세계에서 촛불이나 세슘원자와 같은 완벽하지 않은 카운터로부터 대략적인 것을 어떻게 합성할지에 대해 파악해왔기 때문에 중요합니다. "합성" 함으로써, 우리는 물리적으로 떨어져있는 것끼리 실제적으로 통신하지 않으면서 대략적으로 정수 카운터의 값을 추축할 수 있었죠.

타임스탬프는 우주의 시작으로부터 현재의 순간까지의 세계의 상태를 나타내는 값입니다. - 만약 특정 타임스탬프에서 어떤 일이 일어난다면, 잠재적으로 이전에 일어난 것에 대해 영향을 받았을 수 있습니다. 이 아이디어는 단순히 타임스탬프 이전의 모든것이 관련이 있다고 가정하는 대신에 명시적으로 원인(의존성들)들을 추적하는 캐주얼 클락으로 일반화 될 수 있습니다. 물론 일반적인 가정은 우리는 모든 세계를 걱정하는 것대신 특정 시스템의 상태만 걱정하면 됩니다.

어디에서든 같은 비율로 시간이 흐른다고 가정합시다 - 이것은 대단히 큰 가정인데, 나중에 다시 돌아오겠습니다 - 시간과 타임스탬프들은 몇가지 유용한 해석을 가지고 있는데(프로그램에 있어서) 3가지 해석은 다음과 같습니다: 

- 순서
- 기간
- 해석

`Order`. 제가 시간은 순서의 원천이라고 얘기했을때, 다음을 의미했었습니다:

- 우리는 타임스탬프를 정렬 되지 않은 이벤트를 정렬하기위해 사용할수 있습니다.
- 우리는 타임스탬프를 연산의 특정 순서로 강제하기 위해서, 혹은 메시지의 전달의 순서를 강제하기 위해 사용할 수 있습니다. (예를 들어서, 순서에 다르게 도달하는 연산은 수행을 딜레이하는 형태로요.) 
- 우리는 타임스탬플의 값을 어떤 것이 다른 것보다 시간순으로 더 빨리 일어난 것인지 확인하기 위해 사용할 수 있습니다. 
  
`interpretation` - 시간은 보편적으로 비교가능한 값입니다. 타임스탬프의 절대값은 날짜로 해석될 수 있으며, 이것은 사람에게 유용합니다. 로그파일로부터 시작된 정지 시가능로 부터 얻어진 타임스탬프는, 천재 지변이 있었던 저번 토요일이었다, 라고 이야기 할 수 있습니다. 

`Duration` - 기간은 실세계에서 어떤 관계를 갖는 시간으로 측정될 수 있습니다. 알고리즘은 일반적으로 시계의 절대값이나 날짜의 해석등을 고려하지 않으며, 그렇지만 이들은 어떤 판단을 하기위해 기간을 사용할 수도 있습니다. 특별히, 소요된 시간의 양은 단서를 제공하기도 하는데, 시스템이 파티션 되었거나, 단순히 고 지연의 경험으로 인한 것인지 등에 대한 것이 그렇습니다.

이런 그들의 본성으로, 분산시스템의 컴포넌트 들은 예측가능한 형태로 동작하지 않습니다. 이들은 어떤 순서도 보장하지 않으며, 진행률이나, 지연이없을 수도 있습니다. 각각의 노드들은 지역 순서를 가지고 있습니다. - 실행이 대략 순차적이기 때문에 - 그러나 이 지역 순서들은 각각에 대해서는 독립적입니다. 

순서를 추측하거나, 노출하는것은 가능한 실행의 공간을 줄이는 것의 한 방법입니다. 그리고 가능한 발생을 줄이는 방법의 한 방법입니다. 인류는 어떤 것들이 어떤 순서로든 발생할수 있을때 추리하는것에 어려움을 겪어 왔습니다. - 여기엔 그저 너무 많은 순열들을 고려해야합니다.

## Does time progress at the same rate everywhere?

우리는 모두 직관적인 시간에 대한개념을 각각의 경험으로 이해하고 있습니다. 
불행하게도, 이 직관적인 시간에 대한 개념은 부분순서가 아니라 전체 순서에 대한 상을 그리게끔 합니다. 어떤 것이 동시에 일어나는것보다, 하나다음에 다음것이 일어날 것이라고 상상하게 합니다. 메시지들의 하나의 순서가 다른 순서나 다른 지연을 가지는것 대신 추리하기가쉽습니다.

그러나, 분산시스템을 구현할때 우리는 시간과 순서에 대한 강한 가정을 갖는것을 피해야합니다. 왜냐하면, 이 강한 가정은, 시간이 맞물린 이슈나, 온보드 클럭 이슈가 발생했을때 깨지기가 쉽기 때문입니다. - 게다가, 순서를 노출하는것은 비용을 요구합니다. 보다 적게 결정적이면 우리는 더 tolerate 해지며, 분산시스템의 이점을 더 활용할 수 있게됩니다.


