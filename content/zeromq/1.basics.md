---
title: "1.basics"
date: 2024-05-22T21:37:29+09:00
draft: true
categories: ["zeromq"]
tags: ["MQ", "zeromq"]
author: "nolleh"
---

다음 번역
[](https://zguide.zeromq.org/docs/chapter1/)

# Chapter 1 - Basics

## Fixing The World

프로그래밍의 물리요, 과학은: 사람들이 쉽게 이해하고 사용할 수 있는 빌딩블록을 만들고 함께 큰 문제를 해결하는 데에 있다.  
우리는 연결되어 있는 세상에 살고 있고 현대의 소프트웨어는 세상을 안내한다.   

하지만 데이터와 지식들은 클라우드와 개인 컴퓨터에 존재하고 인터넷은 '연결된' 코드의 잠재성을 제안했지만  
현실은 많은 흥미로운 문제들(건강/교육/경제/..)이 코드를 '연결' 할 방법이 없기 때문에 많은 지식(brain) 을 연결하지 못해 해결되지 못한 채로 남아있다. 

IETF 표준들과같은 많은 노력으로 코드를 연결하기 위한 시도들이 행해졌다. 
어플리케이션 개발자들은 HTTP 를 하나의 솔루션으로 사용하여 '간단한' 문제에는 활용할 수 있겠지만  
이것은 개발자들과 아키텍트들이 큰서버를 생각하고 멍청한 클라이언트들을 구성하도록 격려하면서 문제를 더 악화했다.  

그래서, 현재의 사람들은 여전히 raw UDP 와 raw TCP를 사용한다. 이는 고통스럽고, 느리고, 확장하기 어려우며 중앙화가 필수적이다.
분산P2P 아키텍쳐는 업무를 위해서가아니라대부분 play 를 위해 사용된다. 스카이프나 비트토렌트를 데이터를 교환하기위해 사용하는 어플리케이션이 몇이나 되겠는가?  

이는 다시 프로그래밍의 과학을 다시우리에게 들이민다.  세상을 고치기위해 우리는 두가지가 필요하다. 
1. 아무 코드를 어느 곳에나 있는 아무 코드로 연결할 방법  
2. 이를 가능한한 간단한 빌딩 블럭으로 만들어 유저들이 쉽게 이해하고 사용할 수 있어야 할 것

말도 안되게 간단해 보인다. 그리고 어쩌면 그럴 것도 같다. 이게 요점의 전부다.


## Starting Assumptions

version: 3.2 zeromq.  
you can read C code.  
we write constants like PUSH or SUBSCRIBE, you can imagine they are really called ZMQ_PUSH or ZMQ_SUBSCRIBE if the programming language needs it.  


## Ask and Ye Shall Receive

먼저 코드로 시작해보자. 물론 Hello World 예제부터. 클라이언트와 서버를 만든다. 클라이언트는 "Hello" 를 서버에 전송, "World" 라고 응답 받을 것이다.

```c++
//
//  Hello World server in C++
//  Binds REP socket to tcp://*:5555
//  Expects "Hello" from client, replies with "World"
//
#include <zmq.hpp>
#include <string>
#include <iostream>
#ifndef _WIN32
#include <unistd.h>
#else
#include <windows.h>

#define sleep(n)	Sleep(n)
#endif

int main () {
    //  Prepare our context and socket
    zmq::context_t context (2);
    zmq::socket_t socket (context, zmq::socket_type::rep);
    socket.bind ("tcp://*:5555");

    while (true) {
        zmq::message_t request;

        //  Wait for next request from client
        socket.recv (request, zmq::recv_flags::none);
        std::cout << "Received Hello" << std::endl;

        //  Do some 'work'
        sleep(1);

        //  Send reply back to client
        zmq::message_t reply (5);
        memcpy (reply.data (), "World", 5);
        socket.send (reply, zmq::send_flags::none);
    }
    return 0;
}
```

![](https://zguide.zeromq.org/images/fig2.png)

REQ-REP 소켓쌍은 시작점이다. 클라이언트는 `zmq_send()` 이후 `zmq_recv`() 를 하나의 루프에서 실행한다. 이 외의 어떤 다른 시퀀스(한번에 메시지를두번보낸다거나)   
는 응답값이-1 로 반환된다. 유사하게, 서비스는 `zmq_recv()` 이후 `zmq_send()` 를 보통 필요한 것처럼 순서대로 발행 한다.  

다른 언어에서도 유사하게 사용된다.

```java
package guide;

//
//  Hello World server in Java
//  Binds REP socket to tcp://*:5555
//  Expects "Hello" from client, replies with "World"
//

import org.zeromq.SocketType;
import org.zeromq.ZMQ;
import org.zeromq.ZContext;

public class hwserver
{
    public static void main(String[] args) throws Exception
    {
        try (ZContext context = new ZContext()) {
            // Socket to talk to clients
            ZMQ.Socket socket = context.createSocket(SocketType.REP);
            socket.bind("tcp://*:5555");

            while (!Thread.currentThread().isInterrupted()) {
                byte[] reply = socket.recv(0);
                System.out.println(
                    "Received " + ": [" + new String(reply, ZMQ.CHARSET) + "]"
                );

                Thread.sleep(1000); //  Do some 'work'

                String response = "world";
                socket.send(response.getBytes(ZMQ.CHARSET), 0);
            }
        }
    }
}
```


